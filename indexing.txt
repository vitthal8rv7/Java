Basics of Indexing
————-

Indexing in data structures refers to the process of associating a unique identifier or key with each element or record in a collection, making it easier to locate, retrieve, and manipulate specific elements efficiently. Indexing is commonly used in various data structures and databases to improve the performance of data retrieval operations. it can also consume additional memory and might require maintenance as data changes. Therefore, the choice of indexing strategy depends on factors like the type of data structure, the types of operations performed, memory constraints, and the specific use case.

(OS HDD storage info)
——————————-
We save data/records in HardDisk fixed sized Logical blocks/pages
 if we save some data in HDD (stored on multiple blocks)
If you want to find specific data then 
OS will copy each related block from HDD to RAM and search in that block data
If found, success/hit and return it, if not fetch next block from HDD to RAM, this will continue until
searching  data found or searching complete for all blocks.

But in this process fetch/coping block from HDD to RAM for search is very costly because it I/O operation.

I/O Cost high if data not found or found in some last block.  But here if we use Indexing, 
Indexing will reduce I/O cost, Indexing will reduce the transfer/coping operation on blocks.

How Indexing works? And How It Reduce to Input/Output I/O Cost ?
In Indexing we have Index table where we add key(unique value of each record) and value(address of HDD block where this records is present).

Index table also stored in HDD but Index table very small in size, so each block in HDD can stores 
10 records but same block can store 10000 index entries(key, value) in it.
So That means index table is very small in size so transfer index table from HDD to RAM is very less time taking task as compare to transferring actual records.


Step1. Index Table (It is also stored in HDD, same like other data (in blocks))
Step2. We add key value and pointer in Index Table.
	Key Value: Unique key of data like rollNumber, phoneNumber
	Pointer: Block Number /. Page Number.

How many entries/record(key, value) we should add in indexing?
Two types
	Dense: 1 entry for each record(each block have multiple records i.e. multiple entries per block)
	Sparse:  1 entry for each block(1 entry per block) (this entry called as anchor record)
	Note: we can not use Sparse with unordered/unsorted records.

Step3. In indexing records are always sorted.

worst case time complexity is Log(number of blocks required to store index table) with base 2 + 1(after searching in index table if we found it, we check block address and transferring actual block to RAM for searching record).
But if we compare searching with actual data, then we need to transfer more number of blocks than indexing because Index entry is less small in size as compare to actual records, 
Because entry contain only key value but actual record contains all details like rollNumber, Email, Subjects, Education, photo, identity, feesAmount, Marks[(sub1, marks1), (sub2, marks2)….]


In short, we short our actual record into very small record using Indexing for very fast searching….





Types of indexes
————————

Ordered, Primary Key => Primary O(LogN) + 1
				N => Number of blocks in index table

Ordered, No Primary key => Clustered O(N)
				N => Number of blocks in index table

Un-Ordered, Primary key(only 1 entry)  => Secondary O(N)
				N => Number of blocks in index table

Un-Ordered, No Primary key => Secondary O(N)
				N => Number of blocks in HDD


If Data is sorted and we use primary key in SQL table, SQL will apply primary indexing.
If Data is sorted but we don’t have any unique key, SQL will use clustered indexing.
If Data is un-sorted but we use primary key, SQL will apply secondary indexing
If Data is un-sorted and we don’t have any primary key, SQL will still apply secondary indexing

Option 1 is of type Sparse (O(Log N with base 2)), N => Number of blocks in index table
Option 3 is of type Dense (O(N)), N => Number of blocks in index table

Option 2 is of type Sparse:
	Cluster indexing, Data is sorted but no primary key so, if its sorted then 1 entry from each block so, Worst case scenario: (O(LogN)), N => Number of blocks in Index table.

Option4 is of type Sparse + Dense:
Secondary: O(N) N => Number of blocks in Index table


Note: block hanger used to point to next block.





