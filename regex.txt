Regex
————-

Regex are a powerful tool for pattern matching and text manipulation in Java.
Package java.util.regex is totally dedicated to regex operations. This package consists of three classes: Pattern, Matcher, and PatternSyntaxException

Pattern object is a compiled regex. The Pattern class provides no public constructors. To create a pattern, we must first invoke one of its public static compile methods, which will then return a Pattern object. These methods accept a regular expression as the first argument.
Ex. Pattern pattern = Pattern.compile(“foo”); //Pattern to find in text data

Matcher object interprets the pattern and performs match operations against an input String. It also defines no public constructors. We obtain a Matcher object by invoking the matcher method on a Pattern object.
Ex. Matcher matcher = pattern.matcher(“foo”); //Text data
PatternSyntaxException object is an unchecked exception that indicates a syntax error in a regular expression pattern.

Regex can be apply on following text formats
1.) String
2.) Character Sequences: CharSequence( StringBuilder, StringBuilder, CharBuffer)
3.) Input Streams: FileInputStream, BufferedReader
4.) Readers: Reader, FileReader, FileReader
5.) Command Line Arguments: You can apply regex to command-line arguments


Example1: Match String
————————————-
public void givenText_whenSimpleRegexMatches_thenCorrect() {
    Pattern pattern = Pattern.compile(“foo"); //pattern
    Matcher matcher = pattern.matcher(“foo”);//Text data
 
    assertTrue(matcher.find());
}
find(): The find method keeps advancing through the input text and returns true for every match, so we can use it to find the match count as well
Ex. 
 	int matches = 0;
 	while (matcher.find()) {
 	    matches++;
 	}

















Meta Characters
—————————-
. (Dot): Matches any single character except a newline. For example, a.b matches "axb," "dab," and "a1b" but not “abc.”

* (Asterisk): Matches zero or more occurrences of the preceding character or group. For example, ab*c matches "ac," "abc," "abbc," "abbbbbbc," and so on. 
	example 2: a(bc)*d => ad, abcd, abcbcd, abcbcbcd but not acbd, abcbd, abccd

+ (Plus): Matches one or more occurrences of the preceding character or group. For example, ab+c matches "abc," "abbc," and so on, but not "ac."

? (Question Mark): Matches zero or one occurrence of the preceding character or group. For example, colou?r matches both "color" and "colour."

| (Pipe or Alternation): Acts as an OR operator and is used to match either of the expressions on its left or right side. For example, cat|dog matches either "cat" or “dog” 

[] (Character Class): Defines a character class, which matches any single character within the brackets. For example, [aeiou] matches any vowel. cat, mail, own, you 
	True if one of these found 

[^] (Negation in Character Class): Matches any single character not listed within the brackets. For example, [^0-9] matches any character that is not a digit. 
	True if any of these not found

() (Grouping): Groups characters or sub-patterns together. This is often used with quantifiers like *,  +, or ? to specify the repetition of a group. For example, (abc)+ matches one or more occurrences of “abc."

{} (Quantifiers): Specifies the exact number of occurrences of the preceding character or group. For example, a{3} matches "aaa," and a{2,4} matches "aa," "aaa," or "aaaa."

^ (Caret): Matches the start of a line or string. For example, ^abc matches "abc" at the beginning of a line or string.

$ (Dollar Sign): Matches the end of a line or string. For example, xyz$ matches "xyz" at the end of a line or string.

\ (Escape): Escapes the next character, indicating that it should be treated as a literal character and not as a meta-character. For example, \\ matches a single backslash, and \. matches a period.

















Match of a String literal
————————————-
public void givenText_whenSimpleRegexMatches_thenCorrect() {
    Pattern pattern = Pattern.compile("foo");
    Matcher matcher = pattern.matcher("foo");
 
    System.out.println(matcher.find()); // true
} 

Matches Occurrences
———————————-
public void givenText_whenSimpleRegexMatches_thenCorrect() {
    Pattern pattern = Pattern.compile("foo");
    Matcher matcher = pattern.matcher(“foofoo");
    int count = 0;
    while(true) {
	if(matcher.find()) {
   		count++;
	}
    }	
    System.out.println(count)); // 2
} 

DOT: matches any character
———-
public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
 Caller:  System.out.println(runTest(".", "foo");); // 3

OR Classes: We construct this as [abc]. This matches any of the elements in the set
——————-
public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
 Caller:  System.out.println(runTest("[abc]", "cab");); // 3










OR Classes: We create different words by alternating the first letter with each element of the set, they’re all matched
—————————————-
public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
 Caller:  System.out.println(runTest("[rbc]at", “bat cat rat");); // 3

NOR Classes: anything except this pattern	
———————————————————————-
public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
 Caller:  System.out.println(runTest("[^rbc]at", “bat cat rat lat");); //1 

Range
———————————————————————-
public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
Call:  System.out.println(runTest(“[a-z]”, “bat cat rat lat”)); //12
Call:  System.out.println(runTest(“[A-Z]”, “bat cat rat lat”)); //0 case sensitive
Call:  System.out.println(runTest(“[A-Za-z0-9]”, “Bat 123 rat LAT”)); //12
Call:  System.out.println(runTest("3[0-5]", "Two Uppercase alphabets 34 overall")); //1
Call:  System.out.println(runTest("[1-3[7-9]]", "123456789")); //6 (123789 -> UNION)
Call:  System.out.println(runTest("[1-6&&[3-9]]", "123456789")); //4 (3456) -> INTERSECTION
Call: System.out.println(runTest("[0-9&&[^2468]]","123456789")); //4 (13579)-> SUBSTRACTION

Call: System.out.println(runTest(“\\d”,"123456789")); //9 ANY DIGITS
Call: System.out.println(runTest(“\\D”,"123456789A")); //1 EXCEPT DIGITS
Call: System.out.println(runTest(“\\s”,”123456789 A")); //1 WHITE SPACES
Call: System.out.println(runTest(“\\S”,”123456789 A")); //10 EXCEPT WHITE SPACES
Call: System.out.println(runTest(“\\w”,"123456789A")); //10 ANY ALPHABET AND DIGITS
Call: System.out.println(runTest(“\\W”,”12345A@&“)); //2 EXCEPT ANY ALPHABET AND DIGITS
Call: System.out.println(runTest(“A{3}”,”12AA”)); //0 ‘3 consecutive Occurrences of A’
Call: System.out.println(runTest(“A{2, 3}”,”AAAA”)); //1 ’grouping from higher range to lower’
Call: System.out.println(runTest(“^dog”,"dogs are friendly")); //1 beginning of the text
Call: System.out.println(runTest(“^dog”,”a dogs are friendly")); //0 beginning of the text
Call: System.out.println(runTest(“dog$”,"This is a doggy")); //0 end of the text
Call: System.out.println(runTest(“dog$”,”This is a dog")); //1 end of the text
Pattern Class Methods
—————————————-
public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
Call: System.out.println(runTest(“dog”,”This is a DOG")); //1 CASE_INSENSITIVE

public static int runTest(String regex, String text) {
    Pattern pattern = Pattern.compile(regex, Pattern.COMMENTS);
    Matcher matcher = pattern.matcher(text);
    int matches = 0;
    while (matcher.find()) {
        matches++;
    }
    return matches;
}
Call: System.out.println(runTest(“dog #Comment”,”This is a DOG")); //1 COMMENTS


Matcher Class Methods
—————————————-
public void runTest() {
    Pattern pattern = Pattern.compile("dog");
    Matcher matcher = pattern.matcher("This dog is mine");
    matcher.find();
System.out.println(matcher.start()); //start indices of the match
System.out.println(matcher.end()); //end indices of the match

 }

The matches and lookingAt methods both attempt to match an input sequence against a pattern. The difference is that matches requires the entire input sequence to be matched, while lookingAt doesn’t.

public void runTest() {
    Pattern pattern = Pattern.compile("dog");
    Matcher matcher = pattern.matcher("This dog is mine");
    matcher.find();
System.out.println(matcher.lookingAt()); // input sequence (not entire)
System.out.println(matcher.matches());  // entire input sequence

 }
