Everything about Collections
——————————————-
	Group of individual object as a single entity.

Arrays store fixe size homogeneous data by indexing. If Requirement is auto-increment or auto-decrement sized heterogeneous data then arrays can not fulfil this requirement, but Collection can.

Array: 
	1.) Indexed Collection
	2.) Fixed size
	3.) Homogeneous data
	4.) Zero / Very Less readymade / build in method supports
	5.) No Underlying Data Structure supported 

Collections: 
	1.) Indexed collection + non-indexed collections(linked list, list, map, hash table, queue) 
	2.) Growable (Auto-increment, Auto-decrement)
	3.) Homogeneous data + Heterogeneous data
	4.) readymade / build in methods supports
	5.) Every collection have underlying data structure(standard data structure)
	6.) Easy to use
	7.) insertion order, auto-sorting, time complexity, fast-retrieval, fast-insertion and thread-safety so on…


Collection Interfaces and Classes
———————————-
1.) Collection —> All below class and interface are child of Collection Interface except Map
2.) List —> ArrayList, LinkedList, Vector -> Stack, CopyOnWriteArrayList<E> 
3.) Set —> HashSet, LinkedHashSet, CopyOnWriteArraySet<E>
4.) Queue —> PriorityQueue, 
5.) Map —> HashMap, LinkedHashMap, HashTable
6.) SortedSet 		—> |	
7.) Navigable Set 	—> | TreeSet, ConcurrentSkipListSet<E>

8.) SortedMap 	—> |
9.) Navigable Map 	—> | TreeMap, ConcurrentSkipListMap<K,V>	
10.) Dequeue —>  ArrayDequeue (Extend LinkedList), ConcurrentLinkedDeque<E>
11.) BlockingDeque<E> —> LinkedBlockingDeque<E>
12.) BlockingQueue<E> —> SynchronousQueue<E>, ArrayBlockingQueue<E>, DelayQueue<E extends Delayed>, LinkedBlockingQueue<E>, PriorityBlockingQueue<E>, 
13.) TransferQueue<E> —>  LinkedTransferQueue<E>
 And so on …

Collection Interface defines most common methods which are application for any collection object. It is also called root interface of collection framework. No class implement collection interface directly.

Collections Class defines several utility methods for object like Collections.sort(Collection c), Searching and so on…

==> Every Collection Class serialisable and cloneable. 
==> Except Sorting Interfaces(SortedSet, NavigableSet, SortedMap, Navigable Map) and classes (TreeSet, TreeMap) in all the collection framework interfaces and classes heterogeneous objects are allowed.


List (I):
	0.) Child Interface of Collection(I)
	1.) Insertion Order: Preserved (with respect to index)
	2.) Duplicates: Allowed
	3.) Auto-Sorted: No
	4.) Direct Impl Classes: ArrayList, LinkedList, Vector (—> Stack)[Legacy classes 1.0v]
	5.)


ArrayList
—————
1.) Underlying Data Structure: Resizable/Growable Array
2.) Default Capacity: anything, ( (Current Capacity * (3/2)) + 1)
3.) Best Choice for retrieval 
4.) Worse choice for insertion 
5.) Implement Random Access Interface [Access with same speed(direct by index)]
6.) Default: Non-Synchronised(Not Thread-Safe),  
	synchronisedList = Collections.synchronisedList();//if need synchronisedList
7.) null insertion is possible
[data store in consecutive memory location]

LinkedList
—————
1.) Underlying Data Structure: LinkedList
2.) Default Capacity: ———
3.) Best Choice for insertion 
4.) Worse choice for retrieval
5.) Not Implement Random Access Interface
6.) Default: Non-Synchronised(Not Thread-Safe),  
	synchronisedList = Collections.synchronisedList();//if need synchronisedList
7.) null insertion is possible
8.) LinkedList commonly used to create STACK(LIFO) or QUEUE(FIFO)
9.) LinkedList class also implement Queue Interface (follows FIFO)

Vector
————-
Same like ArrayList except it is ThreadSafe and capacity = currentCapacity*2

Stack
————-
Child class of Vector
Specially design class for LIFO order(stack data structure)

















Set (I):
	0.) Child Interface of Collection(I)
	1.) Insertion Order: Not Preserved
	2.) Duplicates: Not Allowed
	3.) Auto-Sorted: No
	4.) Direct Impl Classes: HashSet (—> LinkedHashSet)
	5.) 

HashSet
—————-
1.) Underlying Data Structure: Hash Table
2.) Default Capacity: 16, (Default Fill Ratio: 0.75 / 75%)
3.) Best Choice for search
4.) Worse choice for ——
5.) Not Implement Random Access Interface
6.) Default: Non-Synchronised(Not Thread-Safe),  
	synchronisedSet = Collections.synchronisedSet();//if need synchronisedSet
7.) null insertion is  possible only once??

LinkedHashSet
————————-
Exactly same as HashSet Except following differences
1.) Underlying Data Structure: Linked List(doubly-linked-list) + Hash Table
2.) Best Choice for add, remove (used in developed cache based applications because cache rules are duplicates not allowed and insertion preserved)
3.) Due to Linked List Insertion Order Preserved


SortedSet (I):
	0.) Child Interface of Set(I)
	1.) Insertion Order: Preserved (Preserved according to some sorted order)
	2.) Duplicates: Not Allowed
	3.) Auto-Sorted: Yes
	4.) Direct Impl Classes: No Class Directly Implement It.
	5.) 

NavigableSet (I):
	0.) Child Interface of SortedSet(I)
	1.) Insertion Order: Preserved (Preserved according to some sorted order)
	2.) Duplicates: Not Allowed(Default) 
		=> (Allowed: if we provide own Comparator for sorting)
	3.) Auto-Sorted: Yes
	4.) Direct Impl Classes: TreeSet
	5.) 

TreeSet
—————-
1.) Underlying Data Structure: BalancedTree
2.) Default Capacity: 16, (Default Fill Ratio: 0.75 / 75%)
3.) Best Choice for auto-sorting data
4.) Worse choice for ——
5.) Not Implement Random Access Interface
6.) Default: Non-Synchronised(Not Thread-Safe),  
	synchronisedSet = Collections.synchronisedSet();//if need synchronisedSet
7.) null insertion is NOT possible.
    
Map (I):(Key, Value)
	0.) Direct child of Object class, Both key and value are Objects only.
	1.) Insertion Order: Not Preserved?????
	2.) Duplicate Keys: Not Allowed, Duplicate Values: Allowed
	3.) Auto-Sorted: No	
	4.) Direct Impl Classes: HashMap, LinkedHashMap, WeakHashMap, 
						IdentityHashMap, Hashtable
	5.) 

Hashtable
—————-
1.) Underlying Data Structure: Hashtable
2.) Default Capacity: 16, (Default Fill Ratio: 0.75 / 75%)
3.) Best Choice for Search
4.) Worse choice for ——
5.) Not Implement Random Access Interface
6.) Default: Synchronised(Thread-Safe),  
7.) null insertion is NOT possible.


HashMap
—————-
1.) Underlying Data Structure: Hash Table ( Internally uses LinkedList / Balance Binary Tree)
2.) Default Capacity: 16, (Default Fill Ratio: 0.75 / 75%)
3.) Best Choice for search
4.) Worse choice for ——
5.) Not Implement Random Access Interface
6.) Default: Non-Synchronised(Not Thread-Safe),  
	synchronisedMap = Collections.synchronisedMap();//if need synchronisedMap
7.) null insertion is not possible

LinkedHashMap
—————————-
Exactly same as HashMap Except following differences
1.) Underlying Data Structure: Linked List(doubly-linked-list) + Hash Table
2.) Best Choice for add, remove (used in developed cache based applications because cache rules are duplicates not allowed and insertion preserved)
3.) Due to Linked List Insertion Order Preserved

IdentityHashMap
—————————-
Exactly same as HashMap Except following differences
Always check / compare reference not content.
Due to this, IdentityHashMap can have duplicate keys 





WeakHashMap
—————————-
Exactly same as HashMap Except following differences
If any Object not have any reference variable but it associated with HashMap then GC collector can not destroy this object. But If any Object not have any reference variable but it associated with WeakHashMap then GC collector can destroy this object.



Note:
Hash Table Data Structure:
	if we print Hash Table data it will print from first bucket (bucket 0) to last bucket (bucket N).
	if any bucket have multiple entries then those will store from left to right and print from Right to left


Properties
—————————————-
Changeable resource fetch from external file using Properties Class. If we update/change resources in external file then we only need to redeploy application but no need to recompile, server restart. 
1.) Underlying Data Structure: Internally uses a Hash table to store its properties.
2.) Default Capacity: ——
3.) Best Choice for    ——
4.) Worse choice for  ——
5.) Not Implement Random Access Interface
6.) Default: Synchronised(Thread-Safe),  
7.) null insertion is NOT possible.
8.) Duplicates allowed: Not allowed for Key
9.) Both Key and Value should be string type.

SortedMap (I):(Key, Value)
	0.) Child Interface of Map(I)
	1.) Insertion Order: Preserved (Preserved according to some sorted order of Keys)
	2.) Duplicate Keys: Not Allowed, Duplicate Values: Allowed
	3.) Auto-Sorted: Yes
	4.) Direct Impl Classes: No Class Directly Implement It.
	5.) 

NavigableMap (I):(Key, Value)
	0.) Child Interface of SortedMap(I)
	1.) Insertion Order: Preserved (Preserved according to some sorted order of Keys)
	2.) Duplicate Keys: Not Allowed, Duplicate Values: Allowed
	3.) Auto-Sorted: Yes
	4.) Direct Impl Classes: TreeMap
	5.) 

TreeMap
——————-
1.) Underlying Data Structure: RED-BLACK TREE
2.) Default Capacity: 16, (Default Fill Ratio: 0.75 / 75%) ??
3.) Best Choice for 
4.) Worse choice for ——
5.) Not Implement Random Access Interface
6.) Default: Non-Synchronised(Not Thread-Safe),  
	synchronisedMap = Collections.synchronisedMap();//if need synchronisedMap
7.) null insertion is not possible for key













Queue (I):
	0.) Child Interface of Collection(I)
	1.) Insertion Order: Preserved (Default: FIFO), (Custom Priority Order)
	2.) Duplicates: Allowed?
	3.) Auto-Sorted: No
	4.) Direct Impl Classes: PriorityQueue, (LinkedList also implements queue)
	5.) 
	6.) Prior To Processing
	7.)

PriorityQueue : Prior to precessing
—————————————-
1.) Underlying Data Structure: Queue?
2.) Default Capacity: ——
3.) Best Choice for    ——
4.) Worse choice for  ——
5.) Not Implement Random Access Interface
6.) Default: Not-Synchronised(Not Thread-Safe),  
7.) null insertion is NOT possible.
8.) Duplicates allowed: Not Allowed
9.) Some platform won’t support PriorityQueue and ThreadPriorities

Some Important methods
Collection Methods                              Map Methods		Queue
add						put			add / offer
addAll						putAll			——
remove					remove		remove / poll	
removeAll					——			peak / element
clear						clear			
retainAll		
size						size	
isEmpty					isEmpty	



























Utility Classes
————————-

1.) Collections
	This class defines several utility methods for collection object like sorting, searching reversing and so on…

Sorting:
	DNSO: public static void sort(List l) //given list will sort by DNSO(object should be homogeneous and comparable, list should not contain null)
	
	CSO(Customised Sorting Oder): public void sort( List l, Comparator c) //Provide comparator with sorting logic 

Searching: 
	public int binarySearch(List l, Object target) // List should be sorted with DSNO, if found return index of target object, if not found return index insertion point with -ve sign (where you can place target object)

	public int binarySearch(List l, Object target, Comparator c) // List should be sorted with CSO, if found return index of target object, if not found return index insertion point with -ve sign (where you can place target object)
Above two search method internally usages binarySearchAlgorithm

Reverse:
	public static void reverse (List l) //reverse given list
	public static Comparator reverseOrder( Comparator c) //reverse the comparator order

ToArray: Collection.toArray(List l)


2.) Arrays
———————-
	This class defines several utility methods for Array object like sorting, searching reversing and so on…

Sorting:
	public static void sort ( primitive[] p ) // DNSO
	public static void sort ( Object[] obj) // DNSO
	public static void sort ( Object[] obj, Comparator c) // CSO

Searching :
public int binarySearch(primitive[] p, primitive target) // Array should be sorted with DNSO
public int binarySearch(Object [] obj, Object target) // Array should be sorted with DNSO
public int binarySearch(Object [] obj, Object target, Comparator c) // Array should be sorted with CSO

Convert To List:  Arrays.asList(array); 
	For existing array, we are not getting new list, we are getting list view of array
If we change the array, that change will be reflect also to the list, and vice-versa.
We can not do add, remove operation because this is array, array is not resizable.
Also, we cant save/have heterogeneous object in this list because internally it is array and array can store only homogeneous object.





Cursors: (Best choice to use for(Object o: ObjectList) OR Java8 Stream concept)
—————
If Requirement is to get the Object one by one from the collection, then we should use cursors.
1.) Enumeration:
——————————-
	Enumeration e = object.elements();
	while(e.hasMoreElements()) {
		System.out.println(e.nextElement()) //get element
	}	
  	
	Drawbacks:
		Applicable only for legacy collection objects.
		Forward only
		Only Read Access, No Remove Capability
		Not able to Add New Object and not able to Replace/Update Object

2.) Iterator
———————-
	Applicable for all collections
	Read + Remove

   Example:			
	Iterator iterator = cityNames.iterator(); 
        	while (iterator.hasNext())  
        	    System.out.print(iterator.next() + " "); 
	     iterator.remove();    
	}

	Drawbacks:
		Forward only
		Not able to Add New Object and not able to Replace/Update Object

3.) ListIterator
————————-
	BiDirectional Cursor (Forward + Backward Direction)
	Only Read Access, No Remove Capability
	Read + Remove + Add New Object + Replace/Update Object
	
Example:
	ListIterator<String> iterator = arrlist.listIterator(5);  
	while(iterator.hasNext ()) {	
		if((iterator.next() == “ListIteratorDemo”)) {
			if(hasPrevious()) {
				if(iterator.previous() == “ListIteratorOldDemo”) {
					iterator.remove();
				} else {
					iterator.set(“ListIteratorOldDemo”);
				}
			} else {
				iterator.add(“ListIteratorDemo”);
			}
		}
	}

	Drawbacks:
		Applicable only for List Interface.	

Sorting
————-
1.) Comparable ( I ) :  It meant for DNSO.
If you implement Comparable (I) then you will get DNSO
	ts.add(“Obj1”);
	//Internally Obje1.compareTo(ObjectWhichIsAlreadyInTreeSet)
	{
		if(Obje1 > ObjectWhichIsAlreadyInTreeSet) 
			return 1; // +ve
		else i if(Obje1 < ObjectWhichIsAlreadyInTreeSet)
			return -1; //-ve
		else return 0; // same data //skip
	}	

2.) Comparator ( I ): It meant for Customised Sorting Oder
	In Collection, if you are not satisfied with DNSO or required new sorting order then implement Comparator (I) and override compare method to add new sorting logic.
And provide Comparator instance to sorting collection like TreeSet, TreeMap and so on…

Comparator ( I ) have two abstract methods, compare and equals method. We need to override only compare method not equals because like any other class or interface Comparator interface also child of Object class, and Object class have equals method so Comparator Interface have Object class equals method.

Override compare method
Input: 10, 2, 8, 9, 5, 6
public 	int compare(Object obj1, Object obj2) { 
	Integer firstObj = (Integer) obj1;
	Integer secondObj = (Integer) obj2;

NOTE: INTEGER class implement Comparable interface so it have its compareTo method.
	1.) return firstObj.compareTo(secondObj); // Ascending order [2, 5, 6, 8, 9, 10]
	2.) return - firstObj.compareTo(secondObj); // Descending order [10, 9, 8, 6, 5, 2]
	3.) return secondObj.compareTo(firstObj); // Descending order [10, 9, 8, 6, 5, 2]
	4.) return - secondObj.compareTo(firstObj); // Ascending order [2, 5, 6, 8, 9, 10]
	5.) return 1 // ( +ve ) Insertion Order Preserved [10, 2, 8, 9, 5, 6]
	6.) return -1 // ( -ve ) Reverse of Insertion Order [6, 5, 9, 8, 2, 10]
	7.) return 0 // For 1st value, It will not compare so 1st value inserted,  [ 10 ]
		  // After 1st value, all will found as Duplicate value and hence all will be skipped

// For String DNSO is Alphabetical order
}

We can add both homogeneous and heterogeneous object in TreeSet/TreeMap(Any Sorting Collection) if object does not implement Comparable interface. If we are defining our own sorting order we can provide sorting logic to both homogeneous and heterogeneous objects. Its upto you, you may can through exception also.

If you want to add user-defined classes in any collection with ( DNSO then that class must implement comparable ) or ( user-defined class required custom sorting order  then we need to provide our own sorting mechanism by implementing comparator and provide it as a argument to collection. )



Concurrent Collection
———————————-

Need of concurrent collection
1.) Most of the traditional collections are NOT THREAD SAFE (Data inconsistency problem)
2.) Traditional Thread Safe Collections have following problem
       At a time only one thread allowed to operation. Collection Object locked by thread.	
       It increase waiting time, performance issue
3.) While one thread iterating collection, 
     Other thread can not do any Modification(add/remove/update) Operation.
     [if we modify, we will get Concurrent modification exception]		

Hence, 
	Traditional Collection is not suitable for scalable multi threaded applications.
To overcome these above problems, we need Concurrent Collection.

1.) ConcurrentHashMap
2.) CopyOnWriteArrayList
3.) CopyOnWriteSet            
And so on…

ConcurrentMap (I)
——————————-
1.) putIfAbsent(Object key, Object value)
		if key is already available, (no action) don’t add new value.
	if key is already available then it will not replace old value with new value,
	it will just skip this action. 

2.) remove(Object key, Object value)
	remove if both match (key as well as value should be match)
	This method check key as well as value, if both matches then only remove the entry.

3.) replace(Object key, Object oldValue, Object newValue)
	replace with new value if and only if Key as well as Old Value matches.
	else no action(return false)

ConcurrentHashMap
————————————-
0.) Implement ConcurrentMap (I) and Map (I)
1.) Underlying Data Structure: Hash Table ( Internally uses LinkedList / Balance Binary Tree)
2.) Default Capacity: 16, (Default Fill Ratio: 0.75 / 75%)
3.) ConcurrentHashMap allows concurrent read and thread safe update operations
	a.) To read operation, thread won’t required any lock.
	b.) To perform update operation thread required lock but not entire map object,
	      It requires only a particular (bucket) part of the map. (Bucket Level Lock)[ConcurrentHashMap divide map into smaller portion which is defined by concurrency level]	 	
4.) Default concurrency level is 16
     That means,
	ConcurrentHashMap allows any number of simultaneous read operation, 
	but only 16(concurrency level) simultaneous update operations.	
	[we can set custom concurrency level ]	
5.) Not Implement Random Access Interface
6.) Any number of read operation and Thread-Safe update operations.
7.) null insertion is not possible for both key and value




Concurrency level: Total map divided into given number of parts. 
—————————-

If bucket/capacity if 16 and concurrency level/number of divided map parts is 16 that means per 1 bucket one lock.

If bucket/capacity if 16 and concurrency level/number of divided map parts is 8 that means per 2 bucket one lock.

If bucket/capacity if 16 and concurrency level/number of divided map parts is 32 that means per 1/2 bucket one lock.


While one thread iterating collection, Other thread did any Modification(add/remove/update) Operation. Then that modified value may or may not reflect in ongoing iteration operation.
If depends on which bucket is changed and which bucket if iterating.


synchronizedMap and Hashtable
—————————————————-
1.) Thread Safety by locking whole object.
2.) At a time only one thread can do operation.
3.) every operation (read/write) required entire object lock.
4.) While one thread iterating collection, Other thread can not do any Modification(add/remove/update) Operation. [if we modify, we will get Concurrent modification exception]	
5.) Fail-Fast
6.) Diff
——-
Null insertion allowed for both key and value in synchronizedMap.
Null insertion NOT allowed for both key and value in Hashtable.
	
 VS

ConcurrentHashMap
—————————————————-
1.) Thread Safety by locking some portion(depend on concurrency level).
2.) At a time any number of thread can do read operation, and at a time specific number of threads (depend on concurrency level) can do modification by locking some portion of it.
3.) modification operation not required entire object lock.
4.) While one thread iterating collection, Other thread can do any Modification(add/remove/update) Operation.
5.) Fail-Safe
6.) Null insertion NOT allowed for both key and value in Hashtable.
	















CopyOnWriteArrayList
————————————-
1.) It is Thread Safe version of ArrayList as the name indicates CopyOnWriteArrayList creates a clone copy of underlying ArrayList for every update operation at certain point both will be synchronised automatically which will take care by JVM only.
	It is costly because for every update operation we required new cloned copy of it.
2.) At a time any number of thread can do read operation. 
3.) modification operation not required entire object lock.
4.) While one thread iterating collection, Other thread can do any Modification(add/remove/update) Operation by cloning object and synchronised by JVM after certain point.
5.) Fail-Safe
6.) Iterator of ArrayList can perform remove operation but Iterator of CopyOnWriteArrayList can`t perform the same. (Mat Be Because CopyOnWriteArrayList perform modification on separate cloned copy so CopyOnWriteArrayList iterator remove any object from the  list, there may be issue/problem occurred while synchronising original copy and cloned copy by JVM.)
If you trying to perform remove operation on iterator of CopyOnWriteArrayList, you will get UnsupportedOperationException.
7.) All List Properties all valid for it.
	0.) Implements List (I)
	1.) Insertion Order: Preserved (with respect to index)
	2.) Duplicates: Allowed
	3.) Best Choice for read operation
	4.) Worse choice for modification operation
	5.) Implement Random Access Interface [Access with same speed(direct by index)]
	6.) null insertion is possible
While one thread iterating list, Other thread did any modification then that modified 
list will not reflect to current iterator because modification will happen on cloned copy,
Which will sync after certain point by JVM.

Methods:
1.) boolean addIfAbsent(Object o)
	Add if not already available. Else skip. (Help to reduce duplicates)
2.) boolean addAllAbsent(Collection c)
	Add if not already available from given list. Else skip. (Help to reduce duplicates)

ArrayList
—————-
1.) Not Thread Safe
2.) While one thread iterating other thread can not perform modification, otherwise we will get ConcurrentModificationException
3.) Iterator is fail-fast.
4.) Iterator of ArrayList can perform remove operation.

SynchronizedList() and Vector
——————————————-
1.) Thread Safe but at a time only one thread can do operation.
Point 2, 3 and 4 are same as a ArrayList

CopyOnWriteArrayList
—————-
1.) Thread Safe
2.) While one thread iterating other thread can perform modification
3.) Iterator is fail-safe.
4.) Iterator of CopyOnWriteArrayList can not perform remove operation.




CopyOnWriteArraySet
———————————-
1.) Internally implemented by CopyOnWriteArrayList 
so all properties of CopyOnWriteArraySet are exactly same as CopyOnWriteArrayList
Except one which is CopyOnWriteArraySet not allowed duplicates objects.

synchronizedSet()
—————————-
1.) Thread Safe but at a time only one thread can do operation.
Point 2, 3 and 4 are same as a ArrayList

