					Git
———————————————————————————————————————————
Git is a distributed version control system (VCS) that is widely used for tracking changes in source code during software development. It was created by Linus Torvalds in 2005.

Git provides the core version control features such as creating repositories, making commits, creating branches, merging changes, and maintaining a history of code changes.

Git operates locally on a developer's machine. It allows you to perform version control tasks without requiring an internet connection or a remote server.

Git Benefits: 

Repository (Repo): A repository is a collection of files, folders, and the history of changes (commits) associated with a software project. It stores the entire history of the project's development.

Remote Repository: A remote repository is a version of the repository that's hosted on a server. It's a centralized location where multiple developers can collaborate and share their code changes.

1.) Distributed Version Control: Every developer has a full copy of the entire repository on their local machine. So Work (locally)Offline and synchronize with remote repositories when connected. 

2.) Branching: Allows developers to work on features, bug fixes, or experiments without affecting the main codebase.

3.) Merging: Merging feature branches into the main branch.

4.) Commit: A Git commit is a way to save changes to your project's source code, along with a message describing what changes you've made.

5.) Pull: In Git, "pull" is used to fetch changes from a remote repository and merge them into the local repository. It's often used to synchronize your local repository with changes made by others.

6.) Push: "Push" is used to upload local commits to a remote repository. 

7.) Clone: Cloning creates a local copy of a remote repository on your machine.

8.) Pull Request (PR): In a collaborative environment like GitHub, a pull request is a request to merge changes from one branch into another. It allows code changes to be reviewed, discussed, and eventually merged into the main codebase. 

9.) Rebase: Reapply your commits on top of another branch. 

10.) Cherry-Pick <commit>: Apply the changes introduced by a specific commit to the current branch.   

11.) Stash: Temporarily save changes that are not ready to be committed.

12.) Revert: Create a new commit that undoes changes made in a specific commit.

13.)  Reset <file>: Unstage changes from a specific file. 

14.) Reset --hard <commit>: Reset your working directory to a specific commit, discarding all changes after that commit.
15.) Switch: It is used to switch between branches or restore working tree files.

16.) Restore: It is used to restore specific files or the working directory to a previous state.








Git workflow refers to the specific processes and practices that a development team follows when using Git for version control. There are several Git workflows that teams can adopt, and the choice of workflow depends on the team's needs, project size, and collaboration style. Here are some common Git workflows:  

Centralized Workflow: In this simple workflow, there is a central repository where all developers commit their changes. Developers clone the repository, make changes locally, and then push them to the central repository. It's suitable for small teams or projects with a linear history of commits. 

Feature Branch Workflow: Each new feature or bug fix is developed on a dedicated branch. Developers create a new branch for their feature, work on it, and then merge it back into the main branch when it's complete. Helps isolate changes and prevents conflicts between different features. 

Gitflow Workflow: Extends the feature branch workflow with defined branches for features, releases, and hotfixes. Involves two main branches: master (for stable releases) and develop (for ongoing development). Feature branches are created from develop and merged back when completed. Releases and hotfixes are managed on dedicated branches. 

Forking Workflow: Often used in open-source projects, contributors fork the main repository to their own accounts. They create feature branches in their forks, push changes, and then create pull requests to request merging their changes into the main repository. Maintainers review the changes and merge them if they meet project standards. 

Pull Request Workflow (GitHub Flow): Similar to the forking workflow but used primarily with platforms like GitHub. Developers create feature branches, push changes to those branches, and then open pull requests (PRs) to request merging their changes into the main branch. Reviews, discussions, and automated checks are performed in the PR before merging. 

Continuous Integration (CI) Workflow: Emphasizes frequent integration of code changes into the main branch through automated testing and building. Developers push changes to a shared branch, and a CI server automatically runs tests, builds, and potentially deploys the application. Ensures that code changes don't break the build or introduce regressions. 

Trunk-Based Development: Developers work on short-lived feature branches that are merged into the main branch (trunk) as soon as possible. Encourages small and frequent merges to minimize conflicts and maintain a continuous integration process. 

It's important to choose a workflow that aligns with your team's development practices and project requirements. Some workflows are more suited for large teams with complex release cycles, while others are simpler and better for smaller teams or individual projects. Regardless of the chosen workflow, proper communication, code review, and collaboration are crucial for successful software development.

 







GitFlow + some adaptions is best choice of web application development.
Git Flow:
	Branching: 
		Feature
		Hot-fixes
		Develop (Long Release)
		Master

++ some adaptions
Continuous Integration (CI): Implement a strong CI/CD process to automate testing, building, and deployment. This is crucial for maintaining the quality of the application, especially in a larger context.

Pull Requests and Code Reviews: Enforce code reviews through pull requests. This ensures that changes are reviewed and tested before being merged into main branches.

Documentation: Place a strong emphasis on documentation. With a larger team and application, clear documentation becomes essential for onboarding new team members and understanding the architecture. 

Release Planning: Plan releases in advance, including feature priorities, resource allocation, and timelines. 

Communication and Collaboration: With a bigger team, effective communication and collaboration tools and practices are even more important. 

Customization: Don't hesitate to customize the workflow further to match the unique requirements of your big web application.
































Git Commands

git init: Initialize a new Git repository in the current directory.
git clone <repository_url>: Clone a remote repository onto your local machine.
git add <file>: Stage changes in a specific file for the next commit.
git add .: Stage all changes in the current directory for the next commit.
git commit -m "<message>": Commit staged changes with a descriptive message.
git status: Display the status of your working directory, showing staged and unstaged changes.
git diff: Show the differences between your working directory and the last commit.
git log: Display the commit history.

git branch: List all branches in the repository.
git branch <branch_name>: Create a new branch.
git checkout <branch_name>: Switch to a different branch.
git switch -c <branch)name>: 
git fetch: Fetch changes from remote repositories without merging them.
git merge <branch_name>: Merge changes from one branch into another.
git pull <remote> <branch>: Fetch and merge changes from a remote repository into your current branch.
git push <remote> <branch>: Push your local commits to a remote repository.
git remote -v: List all remote repositories associated with your local repository.
git remote add <remote_name> <repository_url>: Add a new remote repository.
git remote remove <remote_name>: Remove a remote repository.
git stash: Temporarily save changes that are not ready to be committed.
git stash pop: Apply and remove the most recent stash.
git reset <file>: Unstage changes from a specific file.
git reset --hard <commit>: Reset your working directory to a specific commit, discarding all changes after that commit.
git rebase <branch_name>: Reapply your commits on top of another branch.
git tag <tag_name>: Create a lightweight tag at the current commit.
git tag -a <tag_name> -m "<message>": Create an annotated tag with a message.
git cherry-pick <commit>: Apply the changes introduced by a specific commit to the current branch.
git config: Set or view configuration options for Git.
git show <commit>: Display detailed information about a specific commit.
git rm <file>: Delete a file from both the working directory and Git repository.
git revert <commit>: Create a new commit that undoes changes made in a specific commit.























git init
——————-
Keep in mind that running git init initializes a local Git repository. If you're working with a remote repository (such as on GitHub or GitLab), you'll need to set up the remote repository separately and then connect your local repository to it using the git remote add command.


git clone 
——————-

git clone <repository_url>
Replace <repository_url> with the actual URL of the Git repository you want to clone.

git clone https://github.com/username/myrepo.git
a new directory named "myrepo" will be created in your current directory, and the entire repository's contents will be downloaded to that directory.


git add
------------
git add file1.txt file2.js : To stage specific files 
git add . : To stage all changes in your working directory  
git add my_directory/ : To stage changes within a specific directory and its subdirectories  git add git add -i  : This opens an interactive interface where you can select changes to stage.



git commit
------------
The git commit command is used to save your changes to the Git repository, creating a new commit with a snapshot of your project's current state. Each commit represents a specific set of changes along with a meaningful message that describes what those changes are.    git commit -m "Your commit message here"   
git commit -m “[Bug-JiraBugNumber] [UAT] Your commit message here"   
git commit -m “[Feat-JiraFeatNumber] [DEV] Your commit message here"   
git commit -m “[HotFix-JiraBugNumber] [PROD] Your commit message here"   

You can view the commit history using the git log command
git log


git status
——————
display the current state of your working directory and staging area (index). It shows information about any untracked files, changes that are staged for commit, and changes that are not yet staged.  
command: git status

If we modify file, we can do following actions
Stage modified file: (use "git add <file>..." to update what will be committed) 
Discard modified file: (use "git restore <file>..." to discard changes in working directory)

If we stage file, we can do following actions
Unstaged modified changes: (use "git restore --staged <file>..." to unstage)
Commit changes: git commit -m “commit message.”


git diff
—————-
The git diff command is used to display the differences between two different states of a Git repository, typically showing changes between the working directory and the most recent commit, or between different commits.

Command: git diff

git diff: Difference between working directory and the last commit.
git diff —color-words: This command displays the differences using color highlighting to make additions and deletions more visually distinguishable.
git diff —staged: This command will show the differences between the files in the staging area (files that are ready to be committed) and the last commit.
git diff filename: This will show the differences for the specified file between the working directory and the last commit.
git diff commit_hash1 commit_hash2: This will show the differences between the two specified commits. Replace commit_hash1 and commit_hash2 with the actual hashes of the commits you want to compare.
git diff branch_name1 branch_name2: This will show the differences between two branches, often used to compare feature branches with the main branch.




git log
————-
git log is another useful command in Git that allows you to view the commit history of a repository. It displays a list of commits in reverse chronological order, showing the most recent commits first. This command provides information about each commit, such as the commit hash, author, date, and commit message.

Command: git log
git log —oneline: This command shows a more compact representation of the commit history, displaying only the commit hash and the first line of the commit message. 
git log -n <number> : Replace <number> with the desired number of commits to display. For example, git log -n 5 will show the most recent 5 commits.
git log -p: Adding the -p flag will display the commit history along with the actual changes introduced in each commit.
git log —author=<author_name> :Replace <author_name> with the name or email of the author to filter the commit history by. 
git log —since=<date>: Replace <date> with a specific date or date range to filter the commit history by commits made after that date.
	Example: git log --since=Aug-22-2023\n 
git log --graph --oneline —all: This command provides a graphical representation of the commit history, showing branch and merge information, along with the commit hashes and the first line of the commit messages.

git log --graph —all: commits in details, not in one line.
git log --graph -n 2 







git branch
——————
In Git, the git branch command is used to manage and view branches in your repository.
Command: git branch
If you run git branch without any arguments, it will list all the branches in your repository. The currently checked out branch will be indicated with an asterisk (*).

git branch new-feature: You can use the git branch command followed by a branch name to create a new branch based on your current branch. The new branch will start with the same content as the current branch.

git branch -d branch-name
# or
git branch -D branch-name: To delete a branch, you can use the -d flag with the git branch command. Note that you can't delete the branch you're currently on unless you force it using -D. Be cautious when deleting branches as the changes on the branch will be lost.

git branch -m old-name new-name: To rename a branch, you can use the -m flag with the git branch command.

git branch -r: To view remote branches, you can use the -r flag with the git branch command. This will show you a list of remote branches.






















Git Errors
———————-
"fatal: repository not found" or "Could not resolve host":
This error occurs when the repository URL is incorrect or doesn't exist.
Double-check the repository URL for typos or errors in the URL.
Verify that the repository exists on the hosting platform (e.g., GitHub, GitLab).


"Permission denied (publickey)":
This error occurs when you're trying to clone a repository using SSH, but your SSH key isn't configured or authorized.
Make sure you've added your SSH key to your Git hosting platform (e.g., GitHub) and that your SSH agent is running.


"Username or password authentication failed":
This error might occur if you're using HTTPS to clone the repository and provided incorrect credentials (username/password or personal access token).
Double-check your credentials and make sure they are correct.


"fatal: destination path already exists":
This error occurs when you're trying to clone a repository into a directory that already exists.
Either choose a different directory name or remove the existing directory and then try cloning again.


"Could not create directory":
This error happens when Git doesn't have permission to create a directory in the specified location.
Make sure you have the necessary permissions to create directories in the specified location.


"SSL certificate problem: unable to get local issuer certificate":
This error occurs when Git is unable to verify the SSL certificate of the remote repository.
Ensure that your system's SSL certificates are up to date, or you can configure Git to ignore SSL verification (not recommended for security reasons).
Timeout Errors:
If you're experiencing timeout errors, it could be due to slow network connections or problems with the remote server.
Try cloning again later when your network is stable.
"pathspec did not match any files":
This error occurs when the repository URL is not specified correctly, or the repository doesn't exist.
Verify that you've provided the correct repository URL and that the repository exists.
"remote end hung up unexpectedly":
This error might occur due to network interruptions or server issues on the remote end.
Try cloning again later or check if there are issues with the remote server.

