					Git
———————————————————————————————————————————
Git is a distributed version control system (VCS) that is widely used for tracking changes in source code during software development. It was created by Linus Torvalds in 2005.

Git provides the core version control features such as creating repositories, making commits, creating branches, merging changes, and maintaining a history of code changes.

Git operates locally on a developer's machine. It allows you to perform version control tasks without requiring an internet connection or a remote server.

Git Benefits: 

Repository (Repo): A repository is a collection of files, folders, and the history of changes (commits) associated with a software project. It stores the entire history of the project's development.

Remote Repository: A remote repository is a version of the repository that's hosted on a server. It's a centralized location where multiple developers can collaborate and share their code changes.

1.) Distributed Version Control: Every developer has a full copy of the entire repository on their local machine. So Work (locally)Offline and synchronize with remote repositories when connected. 

2.) Branching: Allows developers to work on features, bug fixes, or experiments without affecting the main codebase.

3.) Merging: Merging feature branches into the main branch.

4.) Commit: A Git commit is a way to save changes to your project's source code, along with a message describing what changes you've made.

5.) Pull: In Git, "pull" is used to fetch changes from a remote repository and merge them into the local repository. It's often used to synchronize your local repository with changes made by others.

6.) Push: "Push" is used to upload local commits to a remote repository. 

7.) Clone: Cloning creates a local copy of a remote repository on your machine.

8.) Pull Request (PR): In a collaborative environment like GitHub, a pull request is a request to merge changes from one branch into another. It allows code changes to be reviewed, discussed, and eventually merged into the main codebase. 

9.) Rebase: Reapply your commits on top of another branch. 

10.) Cherry-Pick <commit>: Apply the changes introduced by a specific commit to the current branch.   

11.) Stash: Temporarily save changes that are not ready to be committed.

12.) Revert: Create a new commit that undoes changes made in a specific commit.

13.)  Reset <file>: Unstage changes from a specific file. 

14.) Reset --hard <commit>: Reset your working directory to a specific commit, discarding all changes after that commit.
15.) Switch: It is used to switch between branches or restore working tree files.

16.) Restore: It is used to restore specific files or the working directory to a previous state.








Git workflow refers to the specific processes and practices that a development team follows when using Git for version control. There are several Git workflows that teams can adopt, and the choice of workflow depends on the team's needs, project size, and collaboration style. Here are some common Git workflows:  

Centralized Workflow: In this simple workflow, there is a central repository where all developers commit their changes. Developers clone the repository, make changes locally, and then push them to the central repository. It's suitable for small teams or projects with a linear history of commits. 

Feature Branch Workflow: Each new feature or bug fix is developed on a dedicated branch. Developers create a new branch for their feature, work on it, and then merge it back into the main branch when it's complete. Helps isolate changes and prevents conflicts between different features. 

Gitflow Workflow: Extends the feature branch workflow with defined branches for features, releases, and hotfixes. Involves two main branches: master (for stable releases) and develop (for ongoing development). Feature branches are created from develop and merged back when completed. Releases and hotfixes are managed on dedicated branches. 

Forking Workflow: Often used in open-source projects, contributors fork the main repository to their own accounts. They create feature branches in their forks, push changes, and then create pull requests to request merging their changes into the main repository. Maintainers review the changes and merge them if they meet project standards. 

Pull Request Workflow (GitHub Flow): Similar to the forking workflow but used primarily with platforms like GitHub. Developers create feature branches, push changes to those branches, and then open pull requests (PRs) to request merging their changes into the main branch. Reviews, discussions, and automated checks are performed in the PR before merging. 

Continuous Integration (CI) Workflow: Emphasizes frequent integration of code changes into the main branch through automated testing and building. Developers push changes to a shared branch, and a CI server automatically runs tests, builds, and potentially deploys the application. Ensures that code changes don't break the build or introduce regressions. 

Trunk-Based Development: Developers work on short-lived feature branches that are merged into the main branch (trunk) as soon as possible. Encourages small and frequent merges to minimize conflicts and maintain a continuous integration process. 

It's important to choose a workflow that aligns with your team's development practices and project requirements. Some workflows are more suited for large teams with complex release cycles, while others are simpler and better for smaller teams or individual projects. Regardless of the chosen workflow, proper communication, code review, and collaboration are crucial for successful software development.

 







GitFlow + some adaptions is best choice of web application development.
Git Flow:
	Branching: 
		Feature
		Hot-fixes
		Develop (Long Release)
		Master

++ some adaptions
Continuous Integration (CI): Implement a strong CI/CD process to automate testing, building, and deployment. This is crucial for maintaining the quality of the application, especially in a larger context.

Pull Requests and Code Reviews: Enforce code reviews through pull requests. This ensures that changes are reviewed and tested before being merged into main branches.

Documentation: Place a strong emphasis on documentation. With a larger team and application, clear documentation becomes essential for onboarding new team members and understanding the architecture. 

Release Planning: Plan releases in advance, including feature priorities, resource allocation, and timelines. 

Communication and Collaboration: With a bigger team, effective communication and collaboration tools and practices are even more important. 

Customization: Don't hesitate to customize the workflow further to match the unique requirements of your big web application.
































Git Commands

git init: Initialize a new Git repository in the current directory.
git clone <repository_url>: Clone a remote repository onto your local machine.
git add <file>: Stage changes in a specific file for the next commit.
git add .: Stage all changes in the current directory for the next commit.
git commit -m "<message>": Commit staged changes with a descriptive message.
git status: Display the status of your working directory, showing staged and unstaged changes.
git diff: Show the differences between your working directory and the last commit.
git log: Display the commit history.
git branch: List all branches in the repository.
git branch <branch_name>: Create a new branch.
git checkout <branch_name>: Switch to a different branch.
git switch -c <branch)name>: 
git fetch: Fetch changes from remote repositories without merging them.

git merge <branch_name>: Merge changes from one branch into another.
git pull <remote> <branch>: Fetch and merge changes from a remote repository into your current branch.
git push <remote> <branch>: Push your local commits to a remote repository.
git remote -v: List all remote repositories associated with your local repository.
git remote add <remote_name> <repository_url>: Add a new remote repository.
git remote remove <remote_name>: Remove a remote repository.
git stash: Temporarily save changes that are not ready to be committed.
git stash pop: Apply and remove the most recent stash.
git reset <file>: Unstage changes from a specific file.
git reset --hard <commit>: Reset your working directory to a specific commit, discarding all changes after that commit.
git rebase <branch_name>: Reapply your commits on top of another branch.
git tag <tag_name>: Create a lightweight tag at the current commit.
git tag -a <tag_name> -m "<message>": Create an annotated tag with a message.
git cherry-pick <commit>: Apply the changes introduced by a specific commit to the current branch.
git config: Set or view configuration options for Git.
git show <commit>: Display detailed information about a specific commit.
git rm <file>: Delete a file from both the working directory and Git repository.
git revert <commit>: Create a new commit that undoes changes made in a specific commit.























git init
——————-
Keep in mind that running git init initializes a local Git repository. If you're working with a remote repository (such as on GitHub or GitLab), you'll need to set up the remote repository separately and then connect your local repository to it using the git remote add command.


git clone 
——————-

git clone <repository_url>
Replace <repository_url> with the actual URL of the Git repository you want to clone.

git clone https://github.com/username/myrepo.git
a new directory named "myrepo" will be created in your current directory, and the entire repository's contents will be downloaded to that directory.


git add
------------
git add file1.txt file2.js : To stage specific files 
git add . : To stage all changes in your working directory  
git add my_directory/ : To stage changes within a specific directory and its subdirectories  git add git add -i  : This opens an interactive interface where you can select changes to stage.



git commit
------------
The git commit command is used to save your changes to the Git repository, creating a new commit with a snapshot of your project's current state. Each commit represents a specific set of changes along with a meaningful message that describes what those changes are.    git commit -m "Your commit message here"   
git commit -m “[Bug-JiraBugNumber] [UAT] Your commit message here"   
git commit -m “[Feat-JiraFeatNumber] [DEV] Your commit message here"   
git commit -m “[HotFix-JiraBugNumber] [PROD] Your commit message here"   

You can view the commit history using the git log command
git log


git status
——————
display the current state of your working directory and staging area (index). It shows information about any untracked files, changes that are staged for commit, and changes that are not yet staged.  
command: git status

If we modify file, we can do following actions
Stage modified file: (use "git add <file>..." to update what will be committed) 
Discard modified file: (use "git restore <file>..." to discard changes in working directory)

If we stage file, we can do following actions
Unstaged modified changes: (use "git restore --staged <file>..." to unstage)
Commit changes: git commit -m “commit message.”


git diff
—————-
The git diff command is used to display the differences between two different states of a Git repository, typically showing changes between the working directory and the most recent commit, or between different commits.

Command: git diff

git diff: Difference between working directory and the last commit.
git diff —color-words: This command displays the differences using color highlighting to make additions and deletions more visually distinguishable.
git diff —staged: This command will show the differences between the files in the staging area (files that are ready to be committed) and the last commit.
git diff filename: This will show the differences for the specified file between the working directory and the last commit.
git diff commit_hash1 commit_hash2: This will show the differences between the two specified commits. Replace commit_hash1 and commit_hash2 with the actual hashes of the commits you want to compare.
git diff branch_name1 branch_name2: This will show the differences between two branches, often used to compare feature branches with the main branch.




git log
————-
git log is another useful command in Git that allows you to view the commit history of a repository. It displays a list of commits in reverse chronological order, showing the most recent commits first. This command provides information about each commit, such as the commit hash, author, date, and commit message.

Command: git log
git log —oneline: This command shows a more compact representation of the commit history, displaying only the commit hash and the first line of the commit message. 
git log -n <number> : Replace <number> with the desired number of commits to display. For example, git log -n 5 will show the most recent 5 commits.
git log -p: Adding the -p flag will display the commit history along with the actual changes introduced in each commit.
git log —author=<author_name> :Replace <author_name> with the name or email of the author to filter the commit history by. 
git log —since=<date>: Replace <date> with a specific date or date range to filter the commit history by commits made after that date.
	Example: git log --since=Aug-22-2023\n 
git log --graph --oneline —all: This command provides a graphical representation of the commit history, showing branch and merge information, along with the commit hashes and the first line of the commit messages.

git log --graph —all: commits in details, not in one line.
git log --graph -n 2 







git branch
——————
In Git, the git branch command is used to manage and view branches in your repository.
Command: git branch
If you run git branch without any arguments, it will list all the branches in your repository. The currently checked out branch will be indicated with an asterisk (*).

git branch new-feature: You can use the git branch command followed by a branch name to create a new branch based on your current branch. The new branch will start with the same content as the current branch.

git branch -d branch-name
# or
git branch -D branch-name: To delete a branch, you can use the -d flag with the git branch command. Note that you can't delete the branch you're currently on unless you force it using -D. Be cautious when deleting branches as the changes on the branch will be lost.

git branch -m old-name new-name: To rename a branch, you can use the -m flag with the git branch command.

git branch -r: To view remote branches, you can use the -r flag with the git branch command. This will show you a list of remote branches.


git checkout
———————
The git checkout command in Git is used to switch between branches, restore files from a specific commit or branch, and generally navigate around your repository. The behavior of git checkout depends on how it's used. However, starting from Git 2.23, it's recommended to use git switch and git restore for better clarity and safety.

git checkout branch-name: You can use git checkout to switch from your current branch to another existing branch.
Alternative Option : git switch branch-name

git checkout -b new-branch-name: You can create a new branch and immediately switch to it using the -b flag.
Alternative Option : git switch -c new-branch-name

git checkout -- filename: You can discard the changes in a specific file and restore it to the state of the last commit using the -- delimiter followed by the filename.
Alternative Option : git restore filename

git checkout commit-hash: You can temporarily switch to a specific commit to view its state using the commit hash. This is referred to as a "detached HEAD" state.
Alternative Option : git switch commit-hash

git checkout branch-name: If you had a branch that was deleted and you want to restore it, you can use git checkout followed by the name of the deleted branch. 
Alternative Option : git switch branch-name

git checkout -b local-branch-name origin/remote-branch-name: To switch to a remote branch (one that's fetched from a remote repository), you typically need to create a local tracking branch first and then switch to it. This can be done using the -b flag with git checkout.
Alternative Option : git switch -c local-branch-name origin/remote-branch-name



git switch
——————
The git switch command is an alternative to git checkout introduced in Git 2.23 to provide a more intuitive and safer way to switch between branches. It's part of Git's efforts to improve the clarity and safety of Git commands. Here's how git switch works:


Switch to an Existing Branch: To switch to an existing branch, you can use the git switch command followed by the branch name.
git switch branch-name

Create and Switch to a New Branch: You can create a new branch and immediately switch to it using the -c or --create flag.
git switch -c new-branch-name

View Available Branches: You can use the git switch command without any arguments to list available branches and indicate the currently checked-out branch.
git switch

Switch to a Specific Commit: You can temporarily switch to a specific commit (detached HEAD state) using its commit hash.
git switch commit-hash

Switch to a Remote Branch: To switch to a remote branch, you need to create a local tracking branch based on the remote branch. The -c flag is used to create and switch to the new local branch.
git switch -c local-branch-name origin/remote-branch-name

Recover Deleted Branch: If a branch was deleted and you want to recover it, you can use git switch followed by the name of the deleted branch.
git switch branch-name



git fetch
—————-
The git fetch command is used to retrieve updates and changes from a remote repository without automatically merging them into your current local branch. It's a useful command for staying up to date with the changes made by other collaborators in the remote repository. 
Command: git fetch



















git merge
——————-
The git merge command in Git is used to integrate changes from one branch into another. It combines the commit history of two branches by creating a new commit that has both branches' changes. This process is known as merging branches. Here's how the git merge command works:

Select Target Branch: To integrate changes from one branch (usually called the source branch) into another (usually called the target branch), you first need to make sure you are on the target branch. You can use git checkout or git switch to switch to the target branch.
git switch target-branch

Initiate Merge: Once you're on the target branch, you can run the git merge command followed by the name of the source branch to initiate the merge process.
git merge source-branch

Resolve Conflicts: If there are no conflicts between the changes on the source and target branches, Git will perform a "fast-forward" merge, which simply moves the target branch pointer to the latest commit of the source branch.
However, if there are conflicting changes on the source and target branches, Git will pause the merge process and indicate the conflicting files. You'll need to manually resolve these conflicts by editing the conflicting files, marking the resolved parts, and then committing the changes.
After resolving conflicts, you need to complete the merge by creating a new commit. Git provides a special commit message during conflict resolution. You can modify this message to provide a clear description of the merge and how conflicts were resolved.

Complete Merge Commit: Once you've resolved the conflicts and are satisfied with the changes, you can commit the merge. This commit will have two parent commits: the last commit of the target branch and the last commit of the source branch.
git commit

Finish Merge: After committing, the merge process is complete. The changes from the source branch are now integrated into the target branch.
Remember that before merging, it's a good practice to ensure your target branch is up to date with the latest changes from the remote repository using git fetch or git pull. This helps minimize the chance of conflicts during the merge. 

It's also worth noting that while merging is a common way to integrate changes, there's another method called "rebasing," which can provide a linear commit history by moving the entire history of one branch onto the top of another. Rebasing is often used to maintain a cleaner and more organized commit history.     



















git pull
—————-

git pull is a Git command used to fetch and integrate changes from a remote repository into the current local branch. It's a combination of two separate Git commands: git fetch and git merge.

When you run git pull, Git performs the following steps:
Fetch: It contacts the remote repository specified by the default remote (usually named "origin") and retrieves any new commits that you don't have in your local repository. However, it doesn't automatically incorporate those changes into your branch.
Merge (or Rebase): After fetching the changes, Git integrates them into your current branch. By default, it does this by creating a new commit that has two parent commits: your current branch's latest commit and the latest commit from the remote branch. This creates a merge commit that represents the integration of the changes from the remote branch into your local branch.
Alternatively, you can use git pull --rebase to perform a rebase instead of a merge. This replays your local commits on top of the fetched commits from the remote branch, resulting in a linear history without merge commits.
Here's the basic syntax of git pull:

git pull [<remote>] [<branch>]
<remote>: Specifies the remote repository to pull from (usually "origin" if not specified).
<branch>: Specifies the branch from the remote repository to pull (defaults to the currently checked-out branch).
It's important to note that if you have uncommitted changes in your local branch, git pull might result in conflicts that you need to resolve. In such cases, Git will stop and prompt you to resolve conflicts before proceeding with the pull.

In a collaborative environment, using git pull helps you keep your local branch up-to-date with the latest changes from the remote repository, allowing for smoother collaboration with other team members. However, just like with any Git command that modifies history, it's essential to be cautious and communicate with your team to avoid disrupting the workflow or introducing conflicts.





























git push
————-
git push is a Git command used to upload your local branch and its associated commits to a remote repository. This command is essential for sharing your changes with others and keeping the remote repository up-to-date.

When you run git push, here's what happens:
Authentication: Git verifies your identity with the remote repository using authentication methods such as SSH keys or username/password credentials. You need the necessary permissions to push to the remote repository.
Upload Commits: Git pushes the commits that are unique to your local branch and are not yet present in the remote repository. This includes all the new commits you've made since your last push.
Update Remote Branch: The remote branch corresponding to your local branch is updated to include the newly pushed commits. If the branch didn't exist remotely, it will be created.
The basic syntax of git push is as follows:

git push <remote> <branch>
<remote>: Specifies the remote repository you want to push to (usually "origin" by default).
<branch>: Specifies the local branch you want to push to the remote repository.
For example, to push the changes in your currently checked-out branch to the remote repository:

git push origin master
It's important to note that git push might fail if you're trying to push to a branch that has new commits in the remote repository that you don't have locally. In such cases, you'll need to perform a git pull to fetch and integrate the remote changes before you can successfully push your own changes.

Additionally, if you're working with a team and you're not the only one contributing to the remote repository, it's a good practice to pull any new changes from the remote repository using git pull before you push your own changes. This helps prevent conflicts and ensures that you have the latest version of the code before you make your own contributions.

Always make sure you understand the implications of pushing changes, especially in shared repositories, to avoid overwriting or conflicting with other people's work.























git remote -v: 
———————-
The git remote -v command is used to display information about the remote repositories associated with your local Git repository. It shows the URLs of the remotes along with their corresponding names. This command is helpful to see where your local repository is connected to, especially when you're collaborating with others or working with multiple remotes.

When you run git remote -v, you'll see a list of remote repositories and their fetch and push URLs. Here's an example of what the output might look like:

origin  https://github.com/username/repo.git (fetch)
origin  https://github.com/username/repo.git (push)
In this example, the remote repository named "origin" has both fetch and push URLs pointing to a GitHub repository.

Here's a breakdown of what the information means:

origin: The name of the remote repository. "origin" is the default name for the remote repository you cloned from.
https://github.com/username/repo.git: The URL of the remote repository.
(fetch): Indicates the URL used for fetching data from the remote repository.
(push): Indicates the URL used for pushing data to the remote repository.
You can have multiple remote repositories associated with your local repository. For example, you might have a primary remote repository named "origin" and additional remotes for collaborating with other team members or for different purposes.

Remember that the URLs shown with git remote -v might be different based on the remote repository protocol (HTTPS, SSH, etc.) and the hosting platform (GitHub, GitLab, Bitbucket, etc.) you are using.



git remote add <remote_name> <repository_url>
—————————————————————————-
The git remote add command is used to add a new remote repository to your local Git repository. This is typically done when you want to connect your local repository to a remote repository hosted on a Git server (like GitHub, GitLab, Bitbucket, etc.). Once you've added a remote, you can use its name to refer to it in various Git commands, such as git pull, git push, and more.

The basic syntax of git remote add is as follows:
git remote add <remote_name> <repository_url>
<remote_name>: The name you want to give to the remote repository. This is the name you'll use to refer to the remote in future Git commands.
<repository_url>: The URL of the remote repository. This URL usually points to the Git hosting service where the remote repository is located.
For example, if you want to add a remote named "origin" that points to a repository hosted on GitHub, you would run a command like this:

git remote add origin https://github.com/username/repo.git
After adding the remote, you can then use the remote name "origin" in commands like git push origin and git pull origin.

It's important to note that the remote name "origin" is commonly used as the default remote name when you clone a repository. However, you can choose a different name if you're working with multiple remotes or if you're setting up a connection to a different repository.

Once you've added a remote, you can verify its addition by using the git remote -v command, which will display a list of remote repositories associated with your local repository along with their URLs.

git remote remove <remote_name>:
—————————————————-
The git remote remove command is used to remove a remote repository from your local Git repository's configuration. This is useful when you no longer want to connect to a particular remote repository or if you want to change the configuration of your repository's remotes.

The basic syntax of git remote remove is as follows:
git remote remove <remote_name>
<remote_name>: The name of the remote repository you want to remove.
For example, if you have a remote named "origin" that you want to remove, you would run a command like this:

git remote remove origin
After running this command, the remote repository named "origin" will no longer be associated with your local repository. You won't be able to use the "origin" remote name in commands like git pull or git push.

Keep in mind that removing a remote doesn't affect the actual remote repository on the server; it only removes the reference to that remote from your local repository's configuration. If you've made changes or commits on branches that were associated with the removed remote, those branches and commits will remain in your local repository.

Before removing a remote, make sure you don't have any unpushed or uncommitted changes that you want to keep. Additionally, if you're working in a collaborative environment, it's a good practice to communicate with your team members before removing a remote to avoid disrupting the workflow.


git stash
—————-
The git stash command is used in Git to temporarily save and hide changes that you've made in your working directory but are not yet ready to commit. This can be useful when you need to switch to a different branch or work on a different task without committing your current changes. Stashing allows you to store your changes away so that you can work on something else and then later come back to your original changes.

Here's how you use the git stash command:
Stash Changes: Run git stash without any arguments:
git stash: This command will save your changes in a new stash entry, reverting your working directory to the state of the last committed version.
Switch Branches or Perform Other Actions: You can now switch branches, perform other operations, or simply take a break from your current work.
Retrieve Stashed Changes: When you're ready to continue working on the changes you stashed, use the git stash apply command to reapply the stashed changes to your working directory:
git stash apply: This will apply the most recent stash, but it will still keep the stash entry intact in case you need it again.
If you have multiple stashes (because you've stashed your changes multiple times), you can use different options to apply or manipulate specific stash entries. For example, you can use git stash list to see a list of stashes and their references, and then use git stash apply stash@{n} to apply a specific stash.

Remember that stashing is a local operation and doesn't affect the remote repository. If you're collaborating with others, you should still commit and push your changes when they're ready to be shared with the team.
Additionally, if you're frequently using git stash, it might be a good time to consider branching more often or using feature branches to better manage your work without needing to stash changes as frequently.
git stash pop: Apply and remove the most recent stash.

git reset <file>: Unstage changes from a specific file.
————————
The git reset <file> command is used in Git to unstage changes for a specific file. When you make changes to files and then use the git add command to stage those changes, they become part of the next commit. If you want to remove a file from the staging area and "unstage" its changes, you can use git reset <file>.

If you want to completely discard changes both from the staging area and the working directory, you can use git checkout -- <file>. However, be cautious with this command, as it discards changes without any possibility of recovery.

If you've already staged changes and want to unstage all changes, you can use git reset without specifying a file: git reset



git reset --hard <commit>
————————————-
The git reset --hard <commit> command is used in Git to reset your current branch and working directory to a specific commit. This can be a powerful command that reverts both your commit history and your working directory contents to match the state of the specified commit.

Here's how you can use the git reset --hard <commit> command:
git reset --hard <commit>
<commit>: The commit hash or reference (like a branch name or a tag) to which you want to reset your repository.

it discards commits and can't be easily undone (unless you have a backup or another reference to the previous state).































git tag <tag_name>: Create a lightweight tag at the current commit.
git tag -a <tag_name> -m "<message>": Create an annotated tag with a message.
————————
he git tag command is used in Git to create a tag, which is a reference to a specific point in your repository's history, usually associated with a specific commit. Tags are often used to mark significant points in your project's development, such as releases or milestones.

The basic syntax of the git tag command is as follows:
git tag <tag_name>
<tag_name>: The name you want to give to the tag. This name can be any alphanumeric string, and it's used to identify the tagged commit.
For example, to create a tag named "v1.0" for the current commit, you would run:
git tag v1.0 
By default, git tag creates what's known as a lightweight tag. Lightweight tags are just references to specific commits, and they don't store any additional information. However, you can also create annotated tags, which store extra information like the tagger's name, email, date, and an optional message.

To create an annotated tag, you can use the -a flag:
git tag -a <tag_name> -m "Tag message"
-a: Indicates that you want to create an annotated tag.
Example: git tag -a v1.0 -m "Version 1.0 release"
git tag: you can list all the tags in your repository using git tag.

Keep in mind that tags are local by default, meaning they are stored in your local repository and are not automatically pushed to remote repositories when you use git push. To push tags to a remote repository, you need to explicitly push them:
git push origin <tag_name>

This pushes the specific tag to the remote repository. If you want to push all tags, you can use:
git push origin --tags




git cherry-pick <commit>: Apply the changes introduced by a specific commit to the current branch.
————————
The git cherry-pick command is used in Git to apply the changes from a specific commit onto the current branch. This command allows you to select individual commits from other branches and apply them to your current working branch, effectively "cherry-picking" the changes you want.

Here's how you can use the git cherry-pick command:
git cherry-pick <commit>
<commit>: The commit hash or reference of the commit you want to apply to the current branch.
It's important to note that git cherry-pick will only apply the changes made in the specified commit, and not the entire commit history. If the changes in the commit you're cherry-picking depend on changes made in earlier commits, you might encounter conflicts that need to be resolved.

If you're cherry-picking multiple commits, you can provide a range of commits:
git cherry-pick <start_commit>..<end_commit>
Additionally, if conflicts occur during the cherry-pick process, you will need to resolve them just like you would with regular merge conflicts. After resolving conflicts, you need to use git cherry-pick --continue to proceed.



git config: Set or view configuration options for Git.
——————————————————————————
The git config command is used in Git to configure various settings related to your Git repository. These settings can be specific to a single repository (--local), to your user account (--global), or system-wide (--system). The git config command is versatile and allows you to manage settings related to your identity, preferred text editors, remote repositories, and more.

Here are the common ways to use the git config command:
Setting Configuration Values:
To set a configuration value, you can use the --local, --global, or --system flag along with the git config command. For example, to set your name and email for all repositories (global configuration), you would run:

git config --global user.name "Your Name"
git config --global user.email "your.email@example.com"
Viewing Configuration Values:
To view configuration values, you can run the git config command without additional options:

git config user.name
git config user.email
Listing All Configuration Settings:
To see all the configuration settings for your current repository, you can use:

git config --list
Editing Configuration Files Directly:
You can also edit the Git configuration files directly if you prefer. The global configuration is usually stored in the ~/.gitconfig file, and the local configuration for a repository is stored in the .git/config file within that repository's directory.
To edit the global configuration:

git config --global --edit
To edit the local configuration of a specific repository:

git config --local --edit
Remember that configuration values set with --global apply to all your repositories, while those set with --local apply only to the specific repository you're currently in. Configuration values set with --system apply to all users on the system.

Git configuration settings cover a wide range of aspects, including user identity, core behavior, aliases, remote repository URLs, and more. The git config command is your tool for manag


git show <commit>: Display detailed information about a specific commit.
——————————
The git show command is used in Git to display information about a specific commit. It shows the details of the commit, including the commit message, author, date, and the changes introduced by the commit.
Here's how you can use the git show command:
git show <commit>
<commit>: The commit hash or reference of the commit you want to show.









git rm <file>: Delete a file from both the working directory and Git repository.
—————————
The git rm command is used in Git to remove a file from both your working directory and the Git repository. This action stages the file's removal for the next commit. When you commit, the file will no longer be part of your repository's history.

Here's how you can use the git rm command:
git rm <file>
<file>: The name of the file you want to remove.

It's important to note that using git rm not only removes the file but also stages its removal in the current branch's staging area. If you commit after running git rm, the file's deletion will be recorded in the commit history.

If you've committed the file's deletion but later realize you want to retrieve it, you can use git checkout <commit> -- <file> to restore the file from a previous commit:
git checkout <commit> -- example.txt


git revert <commit>: Create a new commit that undoes changes made in a specific commit.
——————————-
The git revert command in Git is used to create a new commit that undoes the changes introduced by a specific commit. It's a way to effectively reverse the effects of a previous commit while still preserving a record of the change in your commit history.

Here's how you can use the git revert command:

git revert <commit>
<commit>: The commit hash or reference of the commit you want to revert.

git rebase <branch_name>: Reapply your commits on top of another branch.
——————————
he git rebase <branch_name> command in Git is used to integrate the changes from the specified branch onto the branch you're currently on. It allows you to move your branch's commits to a new base point, effectively changing the branch's history.

When you run git rebase <branch_name>, Git performs the following steps:
Identify Common Ancestor: Git identifies the common ancestor between your current branch (the one you're rebasing) and the specified branch (<branch_name>).
Patch Commits: Git then calculates the changes introduced in each of your branch's commits relative to the common ancestor and applies them one by one onto the latest commit of the specified branch.
Move Branch Pointer: After all commits are applied, Git moves your branch's pointer to the last commit from the specified branch. This effectively places your commits on top of the other branch's commits.

Here’s how you can use the git rebase <branch_name> command:
git rebase <branch_name>
<branch_name>: The name of the branch you want to rebase onto.












Git Errors
———————-
"fatal: repository not found" or "Could not resolve host":
This error occurs when the repository URL is incorrect or doesn't exist.
Double-check the repository URL for typos or errors in the URL.
Verify that the repository exists on the hosting platform (e.g., GitHub, GitLab).


"Permission denied (publickey)":
This error occurs when you're trying to clone a repository using SSH, but your SSH key isn't configured or authorized.
Make sure you've added your SSH key to your Git hosting platform (e.g., GitHub) and that your SSH agent is running.


"Username or password authentication failed":
This error might occur if you're using HTTPS to clone the repository and provided incorrect credentials (username/password or personal access token).
Double-check your credentials and make sure they are correct.


"fatal: destination path already exists":
This error occurs when you're trying to clone a repository into a directory that already exists.
Either choose a different directory name or remove the existing directory and then try cloning again.


"Could not create directory":
This error happens when Git doesn't have permission to create a directory in the specified location.
Make sure you have the necessary permissions to create directories in the specified location.


"SSL certificate problem: unable to get local issuer certificate":
This error occurs when Git is unable to verify the SSL certificate of the remote repository.
Ensure that your system's SSL certificates are up to date, or you can configure Git to ignore SSL verification (not recommended for security reasons).
Timeout Errors:
If you're experiencing timeout errors, it could be due to slow network connections or problems with the remote server.
Try cloning again later when your network is stable.
"pathspec did not match any files":
This error occurs when the repository URL is not specified correctly, or the repository doesn't exist.
Verify that you've provided the correct repository URL and that the repository exists.
"remote end hung up unexpectedly":
This error might occur due to network interruptions or server issues on the remote end.
Try cloning again later or check if there are issues with the remote server.

