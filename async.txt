Async
———-

@Async
	Annotating a method of a bean with @Async will make it execute in a separate thread.
The calling thread won't block for called method to complete. This is especially useful for improving the responsiveness and performance of your application, particularly in scenarios involving I/O-bound or long-running tasks.

@Async has two limitations:
1.) It must be applied to public methods only.
2.) Self-invocation — calling the async method from within the same class — won't work.

@EnableAsync
	To use @Async, you need to enable asynchronous processing in your Spring application. You can do this by adding the @EnableAsync annotation to your configuration class 
	@EnableAsync detects Spring's @Async annotation and the EJB 3.1 javax.ejb.Asynchronous. We can use this option to detect other, user-defined annotation types as well.

@Async
public Future<String> asyncMethodWithReturnType() {
    System.out.println("Execute method asynchronously - " 
      + Thread.currentThread().getName());
    try {
        Thread.sleep(5000);
        return new AsyncResult<String>("hello world !!!!");
    } catch (InterruptedException e) {
        //
    }

    return null;
}
AsyncResult class that implements Future. We can use this to track the result of asynchronous method execution.

//call async
 Future<String> future = asyncAnnotationExample.asyncMethodWithReturnType();
    while (true) {
        if (future.isDone()) {
            System.out.println("Result from asynchronous process - " + future.get());
            break;
        }
        System.out.println("Continue doing something else. ");
        Thread.sleep(1000);
    }



Future
————-
Future.isDone() tells us if the executor has finished processing the task. If the task is complete, it will return true; otherwise, it returns false.

The method that returns the actual result from the calculation is Future.get(). We can see that this method blocks the execution until the task is complete.



CompletableFuture
——————————-

Java 8 introduced the CompletableFuture class. It implements the Future interface so that we can use it as a Future implementation but with additional completion logic. Along with the Future interface, it also implemented the CompletionStage interface. This interface defines the contract for an asynchronous computation step that we can combine with other steps.
	CompletableFuture have 50 different methods for composing, combining, and executing asynchronous computation steps and handling errors. You can use CompletableFuture to handle the result or exception of an asynchronous operation when it completes. You can chain operations, apply transformations, and specify error handling.
———————————————————————————————————-
CompletableFuture<String> result = myService.asyncMethod();
result.thenAccept(r -> {
    // Handle the result when the async method completes successfully
}).exceptionally(ex -> {
    // Handle exceptions when the async method encounters an error
    return "An error occurred: " + ex.getMessage();
});
———————————————————————————————————-
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    // Your asynchronous task logic here
    return 42;
});
future.thenAccept(result -> {
    // Handle the result when the task is complete
});
———————————————————————————————————-
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // Asynchronous computation logic
    return "Result of the computation";
});
Here, the computation inside the supplyAsync method will run asynchronously in a separate thread. Using this we skip boilerplate and execute some code asynchronously.
static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)

The Supplier interface is a generic functional interface with a single method that has no arguments and returns a value of a parameterized type. This allows us to provide an instance of the Supplier as a lambda expression that does the calculation and returns the result.

join(): You can wait for a CompletableFuture to complete using the join method 
get(): To retrieve the result using the get method. Be cautious when using get because it may block the calling thread until the result is available.

CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
int result = future.join(); // Wait for completion and get the result

CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5);
int result = future.get();
		//get the result (if required block the calling thread until the result is available








Chaining Operations:
———————————-

CompletableFuture allows you to chain multiple operations together using methods like thenApply, thenCombine, thenCompose, and more. This enables you to create complex workflows for asynchronous tasks

CompletableFuture provides both synchronous and asynchronous methods. You can use thenApply, thenCombine, etc., for synchronous chaining, or thenApplyAsync, thenCombineAsync, etc., for asynchronous chaining. 

CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> 5)
    .thenApplyAsync(result -> result * 2)
    .thenApplyAsync(result -> result + 3);

Combining Results:
You can combine the results of multiple CompletableFuture instances using methods like thenCombine, thenCombineAsync, and thenCompose.

CompletableFuture<Integer> future1 = CompletableFuture.supplyAsync(() -> 5);
CompletableFuture<Integer> future2 = CompletableFuture.supplyAsync(() -> 3);

CompletableFuture<Integer> combinedFuture = future1.thenCombine(future2, (result1, result2) -> result1 + result2);
































Error Handling:
You can handle exceptions that occur during asynchronous computations using exceptionally or handle methods. This allows you to gracefully manage failures.

CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> {
    // Simulate an exception
    throw new RuntimeException("An error occurred");
}).exceptionally(ex -> {
    // Handle the exception and provide a fallback result
    return 0;
});


ExceptionHandling in Async
——————————————-
When a method return type is a Future, exception handling is easy. Future.get() method will throw the exception.
But if the return type is void, exceptions will not be propagated to the calling thread. So, we need to add extra configurations to handle exceptions. We'll create a custom async exception handler by implementing AsyncUncaughtExceptionHandler interface. The handleUncaughtException() method is invoked when there are any uncaught asynchronous exceptions:

public class CustomAsyncExceptionHandler
  implements AsyncUncaughtExceptionHandler {

    @Override
    public void handleUncaughtException(
      Throwable throwable, Method method, Object... obj) {

        System.out.println("Exception message - " + throwable.getMessage());
        System.out.println("Method name - " + method.getName());
        for (Object param : obj) {
            System.out.println("Parameter value - " + param);
        }
    }
    
}

In the previous section, we looked at the AsyncConfigurer interface implemented by the configuration class. As part of that, we also need to override the getAsyncUncaughtExceptionHandler() method to return our custom asynchronous exception handler:

@Configuration
@EnableAsync
public class SpringAsyncConfig implements AsyncConfigurer {
   @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.initialize();
        return threadPoolTaskExecutor;
    }

	@Override
	public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
	    return new CustomAsyncExceptionHandler();
	}
}

Executor
——————-

By default, Spring uses a simple thread pool (SimpleAsyncTaskExecutor) for executing asynchronous methods. You can customize the thread pool configuration by defining a TaskExecutor bean in your Spring configuration.

Method Level
———————-
We need to declare the required executor in a configuration class then we should provide the executor name as an attribute in @Async:

@Configuration
@EnableAsync
public class SpringAsyncConfig {
    
    @Bean(name = "threadPoolTaskExecutor")
    public Executor threadPoolTaskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(20);
        executor.initialize();
        return executor;
    }
}

@Async("threadPoolTaskExecutor")
public void asyncMethodWithConfiguredExecutor() {
    System.out.println("Execute method with configured executor - "
      + Thread.currentThread().getName());
}

Application level
—————————-
The configuration class should implement the AsyncConfigurer interface. So, it has to implement the getAsyncExecutor() method. Here, we will return the executor for the entire application. This now becomes the default executor to run methods annotated with @Async:

@Configuration
@EnableAsync
public class SpringAsyncConfig implements AsyncConfigurer {

   @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor threadPoolTaskExecutor = new ThreadPoolTaskExecutor();
        threadPoolTaskExecutor.initialize();
        return threadPoolTaskExecutor;
    }
}


