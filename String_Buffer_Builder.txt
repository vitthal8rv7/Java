String, String Buffer, String Builder
——————————————————-

(best in less update and not thread safe)
String: Immutable string sequence. (For each change new instance will be created)

 (best in frequently update and multithreaded application)
String Buffer: Mutable string sequence with synchronization (thread-safe).

(best in frequently update and single application)
String Builder: Mutable string sequence without synchronization (faster in single-threaded scenarios).

1A. String Storage
————————-
 new object created with blank and assign to String Reference Variable
=> String will stored on heap.

new object created by passing “literal” to constructor and assign to String Reference Variable
=> String will stored on heap.
=> One entry also added to String constant pool with given literal (if not already present)

if we use assign literal to String Reference Variable
=> String will stored on String Constant Pool (if not already present)

Note:
String Constant Pool is part of Method Area or PERMGEN till 1.6v, After 1.7v onward for efficient memory utilisation String constant pool moved to Heap Area.
On Method Area SCP  was got fix sized memory, but on heap SCP is expandable.

Whenever you used new operator to create string then new object will be created on heap irrespective of its content. But if you use literal to create string object then no new object created for same content, it will refer to existing SCP object only.

While run time operation like method call if you need create string object, that object always created only in heap area.
Ex. s.concat(“Info”);  //concat method will create new object on heap.

1B. String Buffer Storage
————————-
new object created and assign to String Reference Variable
=> String will stored on heap.

1C. String Builder Storage
————————-
new object created and assign to String Reference Variable
=> String will stored on heap.
===============================================================
2A. String: Immutable
2B. String Buffer: Mutable
2C. String Builder: Mutable
===============================================================
3A. String: Synchronised
3B. String Buffer: Synchronised
3C. String Builder: Non-Synchronised
===============================================================
4A. String: Thread Safe
4B. String Buffer:Thread Safe
4C. String Builder: Not Thread Safe
===============================================================
5A. String: Less Efficient
5B. String Buffer: Efficient
5C. String Builder: More Efficient
===============================================================
6A. String: equals() method do content comparison.
6B. String Buffer: equals() method do reference comparison.
6C. String Builder: equals() method do reference comparison. ===============================================================


Some String Operations
————————————-
String s1 = “abcd”; //created on SCP
String s2 = “ab”+”cd”; // no new “ab” and “cd” object created, because constants concatenation happen at compile time only so it will become “abcd” which is already available on SCP, hence s2 also point to “abcd” where s1 is already pointing.
s1 == s2 //true

final String s3 = “ab”; //new “ab” will create on SCP
String s4 = s3 + “cd”; //here “cd” will create on SCP but s4 will point to existing “abcd” because s3 is final, so final variable value replace by compiler at compile time only so it become “ab” + “cd” => “abcd”, so “abcd” already there in SCP, that why s4 will point to existing “abcd” where s1 and s2 is already pointing.
//new “cd” will create in SCP?  (Not sure, may be not same like s2)
s4 == s1; //true

String s5 = “ab”; //“ab” is already in SCP, s5 point to existing “ab”
s5 == s3; //true 
String s6 = s5 + “cd”; //here new Object created in heap area because s5 is variable and assigning s5 value is run time operation, so rule is In any run time operation, if you need to create String object that will be created in heap area only, irrespective of its contents.
So, s6 will point to newly created object. 
//new “cd” will create in SCP. (Sure)
String s7 = s6.toLowerCase();
s6==s7; //true //while using any method call on String object if there is no change in content, then existing object reference return for assignment whether the object present in Heap area or SCP area. But if due to method call if object changed then new Object get created and return that for assignment.
String s8 = s6.toUpperCase();
s6==s8; //false //change in s6 due to toUpperCase() method call.

SCP => Reuse Object With Content 
	=> Less Memory 
	=> Improve Performance (no need to create new object for same content)
	=> Due to immutability, 
		no one able to change string object which is shared among diff references. 
		if any one tried, it will get new string object with updated(required) content.

SCP share object among multiple object whose contents are same.
SCP is only available for String, because String is frequently used in applications? 
Why String is immutable? String should be immutable so that no one can change the content of shared object by SCP.
StringBuffer and StringBuilder don’t have SCP functionality so no need to make these classes immutable.
All Wrapper classes and String are immutable.